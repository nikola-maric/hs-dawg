
==================== Tidy Core ====================
2021-03-28 14:25:58.779528 UTC

Result size of Tidy Core
  = {terms: 529, types: 927, coercions: 298, joins: 0/4}

-- RHS size: {terms: 11, types: 8, coercions: 0, joins: 0/0}
$WGraph :: Map Int Int -> Int -> Graph
$WGraph
  = \ (dt :: Map Int Int) (dt :: Int) ->
      case dt of dt { __DEFAULT ->
      case dt of dt { __DEFAULT -> Graph dt dt }
      }

-- RHS size: {terms: 8, types: 69, coercions: 137, joins: 0/0}
$cto :: forall x. Rep Graph x -> Graph
$cto
  = \ (@ x) (ds :: Rep Graph x) ->
      case ds `cast` <Co:91> of { :*: ds1 ds2 ->
      $WGraph (ds1 `cast` <Co:25>) (ds2 `cast` <Co:21>)
      }

-- RHS size: {terms: 8, types: 39, coercions: 144, joins: 0/0}
$cfrom :: forall x. Graph -> Rep Graph x
$cfrom
  = \ (@ x) (x1 :: Graph) ->
      case x1 of { Graph g1 g2 ->
      (:*: (g1 `cast` <Co:27>) (g2 `cast` <Co:23>)) `cast` <Co:94>
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$fGenericGraph :: Generic Graph
$fGenericGraph = C:Generic $cfrom $cto

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$dNFData :: NFData (Map Int Int)
$dNFData = $fNFDataMap $fNFDataInt $fNFDataInt

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
$dGNFData :: GNFData Zero (K1 R (Map Int Int))
$dGNFData = $fGNFDataarityK1 $dNFData

-- RHS size: {terms: 2, types: 16, coercions: 0, joins: 0/0}
$dGNFData1
  :: GNFData
       Zero
       (M1
          S
          ('MetaSel
             ('Just "graphTransitions")
             'NoSourceUnpackedness
             'SourceStrict
             'DecidedStrict)
          (Rec0 (Map Int Int)))
$dGNFData1 = $fGNFDataarityM1 $dGNFData

-- RHS size: {terms: 2, types: 3, coercions: 0, joins: 0/0}
$dGNFData2 :: GNFData Zero (K1 R Int)
$dGNFData2 = $fGNFDataarityK1 $fNFDataInt

-- RHS size: {terms: 2, types: 14, coercions: 0, joins: 0/0}
$dGNFData3
  :: GNFData
       Zero
       (M1
          S
          ('MetaSel
             ('Just "graphRootNode")
             'NoSourceUnpackedness
             'SourceStrict
             'DecidedStrict)
          (Rec0 Int))
$dGNFData3 = $fGNFDataarityM1 $dGNFData2

-- RHS size: {terms: 3, types: 33, coercions: 0, joins: 0/0}
$dGNFData4
  :: GNFData
       Zero
       (S1
          ('MetaSel
             ('Just "graphTransitions")
             'NoSourceUnpackedness
             'SourceStrict
             'DecidedStrict)
          (Rec0 (Map Int Int))
        :*: S1
              ('MetaSel
                 ('Just "graphRootNode")
                 'NoSourceUnpackedness
                 'SourceStrict
                 'DecidedStrict)
              (Rec0 Int))
$dGNFData4 = $fGNFDataarity:*: $dGNFData1 $dGNFData3

-- RHS size: {terms: 2, types: 39, coercions: 0, joins: 0/0}
$dGNFData5
  :: GNFData
       Zero
       (M1
          C
          ('MetaCons "Graph" 'PrefixI 'True)
          (S1
             ('MetaSel
                ('Just "graphTransitions")
                'NoSourceUnpackedness
                'SourceStrict
                'DecidedStrict)
             (Rec0 (Map Int Int))
           :*: S1
                 ('MetaSel
                    ('Just "graphRootNode")
                    'NoSourceUnpackedness
                    'SourceStrict
                    'DecidedStrict)
                 (Rec0 Int)))
$dGNFData5 = $fGNFDataarityM1 $dGNFData4

-- RHS size: {terms: 2, types: 48, coercions: 0, joins: 0/0}
$dGNFData6
  :: GNFData
       Zero
       (D1
          ('MetaData "Graph" "DAFSA.Graph" "main" 'False)
          (C1
             ('MetaCons "Graph" 'PrefixI 'True)
             (S1
                ('MetaSel
                   ('Just "graphTransitions")
                   'NoSourceUnpackedness
                   'SourceStrict
                   'DecidedStrict)
                (Rec0 (Map Int Int))
              :*: S1
                    ('MetaSel
                       ('Just "graphRootNode")
                       'NoSourceUnpackedness
                       'SourceStrict
                       'DecidedStrict)
                    (Rec0 Int))))
$dGNFData6 = $fGNFDataarityM1 $dGNFData5

Rec {
-- RHS size: {terms: 4, types: 1, coercions: 7, joins: 0/0}
$crnf :: Graph -> ()
$crnf
  = $dmrnf
      ($crnf `cast` <Co:3>) $fGenericGraph ($dGNFData6 `cast` <Co:4>)
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
$fNFDataGraph :: NFData Graph
$fNFDataGraph = $crnf `cast` <Co:3>

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
graphRootNode :: Graph -> Int
graphRootNode
  = \ (ds :: Graph) ->
      case ds of { Graph ds1 ds2 -> break<69>(ds2) ds2 }

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
graphTransitions :: Graph -> Map Int Int
graphTransitions
  = \ (ds :: Graph) ->
      case ds of { Graph ds1 ds2 -> break<68>(ds1) ds1 }

Rec {
-- RHS size: {terms: 17, types: 12, coercions: 0, joins: 0/0}
foldLPrim :: (Int# -> Char -> Int#) -> Int# -> String -> Int#
foldLPrim
  = \ (ds :: Int# -> Char -> Int#) (b :: Int#) (ds1 :: [Char]) ->
      case ds1 of {
        [] -> break<50>() b;
        : x xs ->
          case break<51>(ds,x) ds b x of app { __DEFAULT ->
          break<52>(ds,xs) foldLPrim ds app xs
          }
      }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: Addr#
$trModule1 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: TrName
$trModule2 = TrNameS $trModule1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: Addr#
$trModule3 = "DAFSA.Graph"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: TrName
$trModule4 = TrNameS $trModule3

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule2 $trModule4

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep :: KindRep
$krep = KindRepTyConApp $tcInt []

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep1 :: [KindRep]
$krep1 = : $krep []

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep2 :: [KindRep]
$krep2 = : $krep $krep1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep3 :: KindRep
$krep3 = KindRepTyConApp $tcMap $krep2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcGraph1 :: Addr#
$tcGraph1 = "Graph"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcGraph2 :: TrName
$tcGraph2 = TrNameS $tcGraph1

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcGraph :: TyCon
$tcGraph
  = TyCon
      12558860687291239446##
      12243563626626252846##
      $trModule
      $tcGraph2
      0#
      krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep4 :: KindRep
$krep4 = KindRepTyConApp $tcGraph []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep5 :: KindRep
$krep5 = KindRepFun $krep $krep4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep6 :: KindRep
$krep6 = KindRepFun $krep3 $krep5

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'Graph1 :: Addr#
$tc'Graph1 = "'Graph"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'Graph2 :: TrName
$tc'Graph2 = TrNameS $tc'Graph1

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'Graph :: TyCon
$tc'Graph
  = TyCon
      8604126356024969318##
      17974004722347734527##
      $trModule
      $tc'Graph2
      0#
      $krep6

-- RHS size: {terms: 20, types: 6, coercions: 3, joins: 0/1}
packNodeId :: ID -> IntSet -> Int
packNodeId
  = \ (_id :: ID) (_terminations :: IntSet) ->
      let {
        intId :: ID
        intId = break<7>(_id) _id } in
      break<11>(_terminations,intId)
      case break<8>(_terminations,intId)
           member (intId `cast` <Co:1>) _terminations
      of {
        False ->
          break<10>(intId) clearBit $fBitsInt (intId `cast` <Co:1>) (I# 31#);
        True ->
          break<9>(intId) setBit $fBitsInt (intId `cast` <Co:1>) (I# 31#)
      }

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
terminations :: IntSet
terminations = break<12>() singleton (I# 1#)

-- RHS size: {terms: 4, types: 0, coercions: 2, joins: 0/0}
truc :: Int
truc
  = break<14>(terminations)
    packNodeId ((break<13>() I# 1#) `cast` <Co:2>) terminations

-- RHS size: {terms: 12, types: 5, coercions: 0, joins: 0/0}
toTransition :: Char -> Int -> Int
toTransition
  = \ (chr :: Char) (nodeId :: Int) ->
      break<18>(nodeId,chr)
      break<17>(nodeId,chr)
      .|.
        $fBitsInt
        (break<16>(chr)
         unsafeShiftL
           $fBitsInt (break<15>(chr) fromEnum $fEnumChar chr) (I# 32#))
        nodeId

-- RHS size: {terms: 87, types: 160, coercions: 2, joins: 0/2}
toGraph :: forall s. GraphBuilder s -> ST s Graph
toGraph
  = \ (@ s) (ds :: GraphBuilder s) ->
      case ds of { GraphBuilder ds1 ds2 ds3 ds4 ->
      break<39>(ds1,ds3,ds4)
      >>=
        $fMonadST
        (break<19>(ds3) readSTRef ds3)
        (\ (_transitions :: Map (ID, Char) ID) ->
           >>=
             $fMonadST
             (break<20>(ds1) readSTRef ds1)
             (\ (_nodes :: Map ID GraphNode) ->
                >>=
                  $fMonadST
                  (break<22>(ds4)
                   <$> $fFunctorST nodeId (break<21>(ds4) readSTRef ds4))
                  (\ (rootNodeId :: ID) ->
                     case break<28>(_nodes)
                          fromList
                            ((break<27>(_nodes)
                              fmap
                                $fFunctor[]
                                fst
                                (break<26>(_nodes)
                                 filter
                                   (\ (ds5 :: (ID, GraphNode)) ->
                                      case ds5 of { (_id, n) ->
                                      break<24>(n)
                                      == $fEqNodeType (break<23>(n) nodeType n) Terminating
                                      })
                                   (break<25>(_nodes) assocs _nodes)))
                             `cast` <Co:2>)
                     of terminations1
                     { __DEFAULT ->
                     let {
                       $dNFData1 :: NFData (Int, Int)
                       $dNFData1 = $fNFData(,) $fNFDataInt $fNFDataInt } in
                     let {
                       $dNFData2 :: NFData [(Int, Int)]
                       $dNFData2 = $fNFData[] $dNFData1 } in
                     case break<35>(_transitions,terminations1)
                          force
                            $dNFData2
                            (break<34>(_transitions,terminations1)
                             fmap
                               $fFunctor[]
                               (\ (ds5 :: ((ID, Char), ID)) ->
                                  case ds5 of { (ds6, cId) ->
                                  case ds6 of { (pId, chr) ->
                                  break<32>(chr,terminations1,pId,cId)
                                  (break<30>(chr,terminations1,pId)
                                   toTransition
                                     chr
                                     (break<29>(terminations1,pId) packNodeId pId terminations1),
                                   break<31>(terminations1,cId) packNodeId cId terminations1)
                                  }
                                  })
                               (break<33>(_transitions) assocs _transitions))
                     of m
                     { __DEFAULT ->
                     break<38>(m,rootNodeId,terminations1)
                     pure
                       $fApplicativeST
                       (case break<36>(m) fromList $fOrdInt m of dt { __DEFAULT ->
                        case break<37>(rootNodeId,terminations1)
                             packNodeId rootNodeId terminations1
                        of dt1
                        { I# ipv ->
                        Graph dt dt1
                        }
                        })
                     }
                     })))
      }

-- RHS size: {terms: 9, types: 20, coercions: 0, joins: 0/0}
fromWordsAst :: [String] -> Graph
fromWordsAst
  = \ (wrds :: [String]) ->
      break<64>(wrds)
      $ runST
        (\ (@ s) -> >>= $fMonadST (break<63>(wrds) build wrds) toGraph)

-- RHS size: {terms: 14, types: 24, coercions: 0, joins: 0/1}
fromWords :: [String] -> Graph
fromWords
  = \ (wrds :: [String]) ->
      break<67>(wrds)
      $ runST
        (\ (@ s) ->
           let {
             $dOrd :: Ord String
             $dOrd = $fOrd[] $fOrdChar } in
           >>=
             $fMonadST
             (break<66>(wrds) build (break<65>(wrds) sort $dOrd wrds))
             toGraph)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$dShow :: Show (Map Int Int)
$dShow = $fShowMap $fShowInt $fShowInt

-- RHS size: {terms: 40, types: 30, coercions: 0, joins: 0/0}
$cshowsPrec :: Int -> Graph -> ShowS
$cshowsPrec
  = \ (a :: Int) (ds :: Graph) ->
      case ds of { Graph b1 b2 ->
      showParen
        (>= $fOrdInt a (I# 11#))
        (. (showString (unpackCString# "Graph {"#))
           (. (showString (unpackCString# "graphTransitions = "#))
              (. (showsPrec $dShow (I# 0#) b1)
                 (. showCommaSpace
                    (. (showString (unpackCString# "graphRootNode = "#))
                       (. (showsPrec $fShowInt (I# 0#) b2)
                          (showString (unpackCString# "}"#))))))))
      }

Rec {
-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
$fShowGraph :: Show Graph
$fShowGraph = C:Show $cshowsPrec $cshow $cshowList

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
$cshowList :: [Graph] -> ShowS
$cshowList = $dmshowList $fShowGraph

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
$cshow :: Graph -> String
$cshow = $dmshow $fShowGraph
end Rec }

Rec {
-- RHS size: {terms: 23, types: 10, coercions: 0, joins: 0/0}
binarz :: Int -> [Int]
binarz
  = \ (ds :: Int) ->
      case ds of wild { I# ds1 ->
      case ds1 of {
        __DEFAULT ->
          break<4>(wild)
          ++
            (break<2>(wild)
             binarz (break<1>(wild) div $fIntegralInt wild (I# 2#)))
            (: (break<3>(wild) mod $fIntegralInt wild (I# 2#)) []);
        0# -> (break<0>() [])
      }
      }
end Rec }

-- RHS size: {terms: 7, types: 5, coercions: 0, joins: 0/0}
toBinaryString :: Int -> String
toBinaryString
  = \ (i :: Int) ->
      break<6>(i)
      concatMap $fFoldable[] (show $fShowInt) (break<5>(i) binarz i)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$dEq :: Eq (Map Int Int)
$dEq = $fEqMap $fEqInt $fEqInt

-- RHS size: {terms: 17, types: 16, coercions: 0, joins: 0/0}
$c== :: Graph -> Graph -> Bool
$c==
  = \ (ds :: Graph) (ds1 :: Graph) ->
      case ds of { Graph a1 a2 ->
      case ds1 of { Graph b1 b2 ->
      && (== $dEq a1 b1) (== $fEqInt a2 b2)
      }
      }

Rec {
-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$fEqGraph :: Eq Graph
$fEqGraph = C:Eq $c== $c/=

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
$c/= :: Graph -> Graph -> Bool
$c/= = $dm/= $fEqGraph
end Rec }

-- RHS size: {terms: 39, types: 19, coercions: 0, joins: 0/0}
handleTransition :: Char -> Int# -> Graph -> Int#
handleTransition
  = \ (chr :: Char) (currentId :: Int#) (g :: Graph) ->
      break<49>(g,chr)
      case break<42>()
           ==
             $fEqInt
             (break<41>()
              case break<40>()
                   case currentId of {
                     __DEFAULT -> 0#;
                     0# -> 1#
                   }
              of wild
              { __DEFAULT ->
              I# wild
              })
             (I# 0#)
      of {
        False ->
          case break<46>(g,chr)
               lookup
                 $fOrdInt
                 (break<44>(chr) toTransition chr (break<43>() I# currentId))
                 (break<45>(g) case g of { Graph ds ds1 -> break<68>(ds) ds })
          of {
            Nothing -> break<47>() 0#;
            Just ds -> case ds of { I# nextId -> break<48>() nextId }
          };
        True -> 0#
      }

-- RHS size: {terms: 12, types: 3, coercions: 0, joins: 0/0}
terminating :: Int# -> Bool
terminating
  = \ (i :: Int#) ->
      break<55>()
      /=
        $fEqInt
        (break<54>()
         case break<53>() andI# i 2147483649# of wild { __DEFAULT ->
         I# wild
         })
        (I# 0#)

-- RHS size: {terms: 37, types: 15, coercions: 0, joins: 0/0}
contains :: String -> Graph -> Bool
contains
  = \ (w :: String) (g :: Graph) ->
      case break<56>(g) case g of { Graph ds ds1 -> break<69>(ds1) ds1 }
      of
      { I# rootIdU ->
      case break<58>(w,g)
           foldLPrim
             (\ (nextId :: Int#) (c :: Char) ->
                break<57>(c,g) handleTransition c nextId g)
             rootIdU
             w
      of transitionPaths
      { __DEFAULT ->
      break<62>()
      &&
        (break<60>() /= $fEqInt (break<59>() I# transitionPaths) (I# 0#))
        (break<61>()
         break<55>()
         /=
           $fEqInt
           (break<54>()
            case break<53>() andI# transitionPaths 2147483649# of wild1
            { __DEFAULT ->
            I# wild1
            })
           (I# 0#))
      }
      }



==================== Tidy Core ====================
2021-03-28 14:31:09.799449 UTC

Result size of Tidy Core
  = {terms: 521, types: 925, coercions: 298, joins: 0/4}

-- RHS size: {terms: 11, types: 8, coercions: 0, joins: 0/0}
$WGraph :: Map Int Int -> Int -> Graph
$WGraph
  = \ (dt :: Map Int Int) (dt :: Int) ->
      case dt of dt { __DEFAULT ->
      case dt of dt { __DEFAULT -> Graph dt dt }
      }

-- RHS size: {terms: 8, types: 69, coercions: 137, joins: 0/0}
$cto :: forall x. Rep Graph x -> Graph
$cto
  = \ (@ x) (ds :: Rep Graph x) ->
      case ds `cast` <Co:91> of { :*: ds1 ds2 ->
      $WGraph (ds1 `cast` <Co:25>) (ds2 `cast` <Co:21>)
      }

-- RHS size: {terms: 8, types: 39, coercions: 144, joins: 0/0}
$cfrom :: forall x. Graph -> Rep Graph x
$cfrom
  = \ (@ x) (x1 :: Graph) ->
      case x1 of { Graph g1 g2 ->
      (:*: (g1 `cast` <Co:27>) (g2 `cast` <Co:23>)) `cast` <Co:94>
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$fGenericGraph :: Generic Graph
$fGenericGraph = C:Generic $cfrom $cto

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$dNFData :: NFData (Map Int Int)
$dNFData = $fNFDataMap $fNFDataInt $fNFDataInt

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
$dGNFData :: GNFData Zero (K1 R (Map Int Int))
$dGNFData = $fGNFDataarityK1 $dNFData

-- RHS size: {terms: 2, types: 16, coercions: 0, joins: 0/0}
$dGNFData1
  :: GNFData
       Zero
       (M1
          S
          ('MetaSel
             ('Just "graphTransitions")
             'NoSourceUnpackedness
             'SourceStrict
             'DecidedStrict)
          (Rec0 (Map Int Int)))
$dGNFData1 = $fGNFDataarityM1 $dGNFData

-- RHS size: {terms: 2, types: 3, coercions: 0, joins: 0/0}
$dGNFData2 :: GNFData Zero (K1 R Int)
$dGNFData2 = $fGNFDataarityK1 $fNFDataInt

-- RHS size: {terms: 2, types: 14, coercions: 0, joins: 0/0}
$dGNFData3
  :: GNFData
       Zero
       (M1
          S
          ('MetaSel
             ('Just "graphRootNode")
             'NoSourceUnpackedness
             'SourceStrict
             'DecidedStrict)
          (Rec0 Int))
$dGNFData3 = $fGNFDataarityM1 $dGNFData2

-- RHS size: {terms: 3, types: 33, coercions: 0, joins: 0/0}
$dGNFData4
  :: GNFData
       Zero
       (S1
          ('MetaSel
             ('Just "graphTransitions")
             'NoSourceUnpackedness
             'SourceStrict
             'DecidedStrict)
          (Rec0 (Map Int Int))
        :*: S1
              ('MetaSel
                 ('Just "graphRootNode")
                 'NoSourceUnpackedness
                 'SourceStrict
                 'DecidedStrict)
              (Rec0 Int))
$dGNFData4 = $fGNFDataarity:*: $dGNFData1 $dGNFData3

-- RHS size: {terms: 2, types: 39, coercions: 0, joins: 0/0}
$dGNFData5
  :: GNFData
       Zero
       (M1
          C
          ('MetaCons "Graph" 'PrefixI 'True)
          (S1
             ('MetaSel
                ('Just "graphTransitions")
                'NoSourceUnpackedness
                'SourceStrict
                'DecidedStrict)
             (Rec0 (Map Int Int))
           :*: S1
                 ('MetaSel
                    ('Just "graphRootNode")
                    'NoSourceUnpackedness
                    'SourceStrict
                    'DecidedStrict)
                 (Rec0 Int)))
$dGNFData5 = $fGNFDataarityM1 $dGNFData4

-- RHS size: {terms: 2, types: 48, coercions: 0, joins: 0/0}
$dGNFData6
  :: GNFData
       Zero
       (D1
          ('MetaData "Graph" "DAFSA.Graph" "main" 'False)
          (C1
             ('MetaCons "Graph" 'PrefixI 'True)
             (S1
                ('MetaSel
                   ('Just "graphTransitions")
                   'NoSourceUnpackedness
                   'SourceStrict
                   'DecidedStrict)
                (Rec0 (Map Int Int))
              :*: S1
                    ('MetaSel
                       ('Just "graphRootNode")
                       'NoSourceUnpackedness
                       'SourceStrict
                       'DecidedStrict)
                    (Rec0 Int))))
$dGNFData6 = $fGNFDataarityM1 $dGNFData5

Rec {
-- RHS size: {terms: 4, types: 1, coercions: 7, joins: 0/0}
$crnf :: Graph -> ()
$crnf
  = $dmrnf
      ($crnf `cast` <Co:3>) $fGenericGraph ($dGNFData6 `cast` <Co:4>)
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
$fNFDataGraph :: NFData Graph
$fNFDataGraph = $crnf `cast` <Co:3>

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
graphRootNode :: Graph -> Int
graphRootNode
  = \ (ds :: Graph) ->
      case ds of { Graph ds1 ds2 -> break<68>(ds2) ds2 }

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
graphTransitions :: Graph -> Map Int Int
graphTransitions
  = \ (ds :: Graph) ->
      case ds of { Graph ds1 ds2 -> break<67>(ds1) ds1 }

Rec {
-- RHS size: {terms: 17, types: 12, coercions: 0, joins: 0/0}
foldLPrim :: (Int# -> Char -> Int#) -> Int# -> String -> Int#
foldLPrim
  = \ (ds :: Int# -> Char -> Int#) (b :: Int#) (ds1 :: [Char]) ->
      case ds1 of {
        [] -> break<49>() b;
        : x xs ->
          case break<50>(ds,x) ds b x of app { __DEFAULT ->
          break<51>(ds,xs) foldLPrim ds app xs
          }
      }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: Addr#
$trModule1 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: TrName
$trModule2 = TrNameS $trModule1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: Addr#
$trModule3 = "DAFSA.Graph"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: TrName
$trModule4 = TrNameS $trModule3

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule2 $trModule4

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep :: KindRep
$krep = KindRepTyConApp $tcInt []

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep1 :: [KindRep]
$krep1 = : $krep []

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep2 :: [KindRep]
$krep2 = : $krep $krep1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep3 :: KindRep
$krep3 = KindRepTyConApp $tcMap $krep2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcGraph1 :: Addr#
$tcGraph1 = "Graph"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcGraph2 :: TrName
$tcGraph2 = TrNameS $tcGraph1

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcGraph :: TyCon
$tcGraph
  = TyCon
      12558860687291239446##
      12243563626626252846##
      $trModule
      $tcGraph2
      0#
      krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep4 :: KindRep
$krep4 = KindRepTyConApp $tcGraph []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep5 :: KindRep
$krep5 = KindRepFun $krep $krep4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep6 :: KindRep
$krep6 = KindRepFun $krep3 $krep5

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'Graph1 :: Addr#
$tc'Graph1 = "'Graph"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'Graph2 :: TrName
$tc'Graph2 = TrNameS $tc'Graph1

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'Graph :: TyCon
$tc'Graph
  = TyCon
      8604126356024969318##
      17974004722347734527##
      $trModule
      $tc'Graph2
      0#
      $krep6

-- RHS size: {terms: 20, types: 6, coercions: 3, joins: 0/1}
packNodeId :: ID -> IntSet -> Int
packNodeId
  = \ (_id :: ID) (_terminations :: IntSet) ->
      let {
        intId :: ID
        intId = break<7>(_id) _id } in
      break<11>(_terminations,intId)
      case break<8>(_terminations,intId)
           member (intId `cast` <Co:1>) _terminations
      of {
        False ->
          break<10>(intId) clearBit $fBitsInt (intId `cast` <Co:1>) (I# 31#);
        True ->
          break<9>(intId) setBit $fBitsInt (intId `cast` <Co:1>) (I# 31#)
      }

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
terminations :: IntSet
terminations = break<12>() singleton (I# 1#)

-- RHS size: {terms: 4, types: 0, coercions: 2, joins: 0/0}
truc :: Int
truc
  = break<14>(terminations)
    packNodeId ((break<13>() I# 1#) `cast` <Co:2>) terminations

-- RHS size: {terms: 12, types: 5, coercions: 0, joins: 0/0}
toTransition :: Char -> Int -> Int
toTransition
  = \ (chr :: Char) (nodeId :: Int) ->
      break<18>(nodeId,chr)
      break<17>(nodeId,chr)
      .|.
        $fBitsInt
        (break<16>(chr)
         unsafeShiftL
           $fBitsInt (break<15>(chr) fromEnum $fEnumChar chr) (I# 32#))
        nodeId

-- RHS size: {terms: 87, types: 160, coercions: 2, joins: 0/2}
toGraph :: forall s. GraphBuilder s -> ST s Graph
toGraph
  = \ (@ s) (ds :: GraphBuilder s) ->
      case ds of { GraphBuilder ds1 ds2 ds3 ds4 ->
      break<39>(ds1,ds3,ds4)
      >>=
        $fMonadST
        (break<19>(ds3) readSTRef ds3)
        (\ (_transitions :: Map (ID, Char) ID) ->
           >>=
             $fMonadST
             (break<20>(ds1) readSTRef ds1)
             (\ (_nodes :: Map ID GraphNode) ->
                >>=
                  $fMonadST
                  (break<22>(ds4)
                   <$> $fFunctorST nodeId (break<21>(ds4) readSTRef ds4))
                  (\ (rootNodeId :: ID) ->
                     case break<28>(_nodes)
                          fromList
                            ((break<27>(_nodes)
                              fmap
                                $fFunctor[]
                                fst
                                (break<26>(_nodes)
                                 filter
                                   (\ (ds5 :: (ID, GraphNode)) ->
                                      case ds5 of { (_id, n) ->
                                      break<24>(n)
                                      == $fEqNodeType (break<23>(n) nodeType n) Terminating
                                      })
                                   (break<25>(_nodes) assocs _nodes)))
                             `cast` <Co:2>)
                     of terminations1
                     { __DEFAULT ->
                     let {
                       $dNFData1 :: NFData (Int, Int)
                       $dNFData1 = $fNFData(,) $fNFDataInt $fNFDataInt } in
                     let {
                       $dNFData2 :: NFData [(Int, Int)]
                       $dNFData2 = $fNFData[] $dNFData1 } in
                     case break<35>(_transitions,terminations1)
                          force
                            $dNFData2
                            (break<34>(_transitions,terminations1)
                             fmap
                               $fFunctor[]
                               (\ (ds5 :: ((ID, Char), ID)) ->
                                  case ds5 of { (ds6, cId) ->
                                  case ds6 of { (pId, chr) ->
                                  break<32>(chr,terminations1,pId,cId)
                                  (break<30>(chr,terminations1,pId)
                                   toTransition
                                     chr
                                     (break<29>(terminations1,pId) packNodeId pId terminations1),
                                   break<31>(terminations1,cId) packNodeId cId terminations1)
                                  }
                                  })
                               (break<33>(_transitions) assocs _transitions))
                     of m
                     { __DEFAULT ->
                     break<38>(m,rootNodeId,terminations1)
                     pure
                       $fApplicativeST
                       (case break<36>(m) fromList $fOrdInt m of dt { __DEFAULT ->
                        case break<37>(rootNodeId,terminations1)
                             packNodeId rootNodeId terminations1
                        of dt1
                        { I# ipv ->
                        Graph dt dt1
                        }
                        })
                     }
                     })))
      }

-- RHS size: {terms: 9, types: 20, coercions: 0, joins: 0/0}
fromWordsAst :: [String] -> Graph
fromWordsAst
  = \ (wrds :: [String]) ->
      break<63>(wrds)
      $ runST
        (\ (@ s) -> >>= $fMonadST (break<62>(wrds) build wrds) toGraph)

-- RHS size: {terms: 14, types: 24, coercions: 0, joins: 0/1}
fromWords :: [String] -> Graph
fromWords
  = \ (wrds :: [String]) ->
      break<66>(wrds)
      $ runST
        (\ (@ s) ->
           let {
             $dOrd :: Ord String
             $dOrd = $fOrd[] $fOrdChar } in
           >>=
             $fMonadST
             (break<65>(wrds) build (break<64>(wrds) sort $dOrd wrds))
             toGraph)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$dShow :: Show (Map Int Int)
$dShow = $fShowMap $fShowInt $fShowInt

-- RHS size: {terms: 40, types: 30, coercions: 0, joins: 0/0}
$cshowsPrec :: Int -> Graph -> ShowS
$cshowsPrec
  = \ (a :: Int) (ds :: Graph) ->
      case ds of { Graph b1 b2 ->
      showParen
        (>= $fOrdInt a (I# 11#))
        (. (showString (unpackCString# "Graph {"#))
           (. (showString (unpackCString# "graphTransitions = "#))
              (. (showsPrec $dShow (I# 0#) b1)
                 (. showCommaSpace
                    (. (showString (unpackCString# "graphRootNode = "#))
                       (. (showsPrec $fShowInt (I# 0#) b2)
                          (showString (unpackCString# "}"#))))))))
      }

Rec {
-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
$fShowGraph :: Show Graph
$fShowGraph = C:Show $cshowsPrec $cshow $cshowList

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
$cshowList :: [Graph] -> ShowS
$cshowList = $dmshowList $fShowGraph

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
$cshow :: Graph -> String
$cshow = $dmshow $fShowGraph
end Rec }

Rec {
-- RHS size: {terms: 23, types: 10, coercions: 0, joins: 0/0}
binarz :: Int -> [Int]
binarz
  = \ (ds :: Int) ->
      case ds of wild { I# ds1 ->
      case ds1 of {
        __DEFAULT ->
          break<4>(wild)
          ++
            (break<2>(wild)
             binarz (break<1>(wild) div $fIntegralInt wild (I# 2#)))
            (: (break<3>(wild) mod $fIntegralInt wild (I# 2#)) []);
        0# -> (break<0>() [])
      }
      }
end Rec }

-- RHS size: {terms: 7, types: 5, coercions: 0, joins: 0/0}
toBinaryString :: Int -> String
toBinaryString
  = \ (i :: Int) ->
      break<6>(i)
      concatMap $fFoldable[] (show $fShowInt) (break<5>(i) binarz i)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$dEq :: Eq (Map Int Int)
$dEq = $fEqMap $fEqInt $fEqInt

-- RHS size: {terms: 17, types: 16, coercions: 0, joins: 0/0}
$c== :: Graph -> Graph -> Bool
$c==
  = \ (ds :: Graph) (ds1 :: Graph) ->
      case ds of { Graph a1 a2 ->
      case ds1 of { Graph b1 b2 ->
      && (== $dEq a1 b1) (== $fEqInt a2 b2)
      }
      }

Rec {
-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$fEqGraph :: Eq Graph
$fEqGraph = C:Eq $c== $c/=

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
$c/= :: Graph -> Graph -> Bool
$c/= = $dm/= $fEqGraph
end Rec }

-- RHS size: {terms: 31, types: 17, coercions: 0, joins: 0/0}
handleTransition :: Char -> Int# -> Graph -> Int#
handleTransition
  = \ (chr :: Char) (currentId :: Int#) (g :: Graph) ->
      break<48>(g,chr)
      case break<41>() == $fEqInt (break<40>() I# currentId) (I# 0#) of {
        False ->
          case break<45>(g,chr)
               lookup
                 $fOrdInt
                 (break<43>(chr) toTransition chr (break<42>() I# currentId))
                 (break<44>(g) case g of { Graph ds ds1 -> break<67>(ds) ds })
          of {
            Nothing -> break<46>() 0#;
            Just ds -> case ds of { I# nextId -> break<47>() nextId }
          };
        True -> 0#
      }

-- RHS size: {terms: 12, types: 3, coercions: 0, joins: 0/0}
terminating :: Int# -> Bool
terminating
  = \ (i :: Int#) ->
      break<54>()
      /=
        $fEqInt
        (break<53>()
         case break<52>() andI# i 2147483649# of wild { __DEFAULT ->
         I# wild
         })
        (I# 0#)

-- RHS size: {terms: 37, types: 15, coercions: 0, joins: 0/0}
contains :: String -> Graph -> Bool
contains
  = \ (w :: String) (g :: Graph) ->
      case break<55>(g) case g of { Graph ds ds1 -> break<68>(ds1) ds1 }
      of
      { I# rootIdU ->
      case break<57>(w,g)
           foldLPrim
             (\ (nextId :: Int#) (c :: Char) ->
                break<56>(c,g) handleTransition c nextId g)
             rootIdU
             w
      of transitionPaths
      { __DEFAULT ->
      break<61>()
      &&
        (break<59>() /= $fEqInt (break<58>() I# transitionPaths) (I# 0#))
        (break<60>()
         break<54>()
         /=
           $fEqInt
           (break<53>()
            case break<52>() andI# transitionPaths 2147483649# of wild1
            { __DEFAULT ->
            I# wild1
            })
           (I# 0#))
      }
      }


